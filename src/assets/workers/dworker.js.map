{"version":3,"file":"dworker.js","sources":["../../../node_modules/rxjs/util/tryCatch.js","../../../node_modules/rxjs/Subscription.js","../../../node_modules/rxjs/util/pipe.js","../../app/config-models/worker-message-types.ts","../../app/fit-logger-core/logging.models.ts","../../app/config-models/worker-message.ts","../../app/worker-services/worker-agent.ts","../../app/fit-logger/appenders/server.appender.ts","../../app/fit-logger/appenders/console.appender.ts","../../app/fit-logger/appenders/worker.appender.ts","../../app/fit-logger/appenders/appender.repository.ts","../../../node_modules/rxjs/util/root.js","../../../node_modules/rxjs/util/isFunction.js","../../../node_modules/rxjs/util/isArray.js","../../../node_modules/rxjs/util/isObject.js","../../../node_modules/rxjs/util/errorObject.js","../../../node_modules/rxjs/util/UnsubscriptionError.js","../../../node_modules/rxjs/Observer.js","../../../node_modules/rxjs/symbol/rxSubscriber.js","../../../node_modules/rxjs/Subscriber.js","../../../node_modules/rxjs/util/toSubscriber.js","../../../node_modules/rxjs/symbol/observable.js","../../../node_modules/rxjs/util/noop.js","../../../node_modules/rxjs/Observable.js","../../../node_modules/rxjs/util/isNumeric.js","../../../node_modules/rxjs/scheduler/Action.js","../../../node_modules/rxjs/scheduler/AsyncAction.js","../../../node_modules/rxjs/Scheduler.js","../../../node_modules/rxjs/scheduler/AsyncScheduler.js","../../../node_modules/rxjs/scheduler/async.js","../../../node_modules/rxjs/observable/IntervalObservable.js","../../../node_modules/rxjs/observable/interval.js","../../../node_modules/rxjs/add/observable/interval.js","../../../node_modules/rxjs/operators/filter.js","../../../node_modules/rxjs/operator/filter.js","../../../node_modules/rxjs/add/operator/filter.js","../../app/fit-logger/logwriters/log.writer.ts","../../app/fit-logger/logwriters/logging.controller.ts","../../app/fit-logger/models/log-event.ts","../../app/fit-logger/logwriters/app.logger.ts","../../app/fit-logger/fit-worker-logger.service.ts","../../app/worker-services/dedicated-worker-gateway.ts"],"sourcesContent":["\"use strict\";\nvar errorObject_1 = require('./errorObject');\nvar tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        return tryCatchTarget.apply(this, arguments);\n    }\n    catch (e) {\n        errorObject_1.errorObject.e = e;\n        return errorObject_1.errorObject;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\nexports.tryCatch = tryCatch;\n;\n//# sourceMappingURL=tryCatch.js.map","\"use strict\";\nvar isArray_1 = require('./util/isArray');\nvar isObject_1 = require('./util/isObject');\nvar isFunction_1 = require('./util/isFunction');\nvar tryCatch_1 = require('./util/tryCatch');\nvar errorObject_1 = require('./util/errorObject');\nvar UnsubscriptionError_1 = require('./util/UnsubscriptionError');\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nvar Subscription = (function () {\n    /**\n     * @param {function(): void} [unsubscribe] A function describing how to\n     * perform the disposal of resources when the `unsubscribe` method is called.\n     */\n    function Subscription(unsubscribe) {\n        /**\n         * A flag to indicate whether this Subscription has already been unsubscribed.\n         * @type {boolean}\n         */\n        this.closed = false;\n        this._parent = null;\n        this._parents = null;\n        this._subscriptions = null;\n        if (unsubscribe) {\n            this._unsubscribe = unsubscribe;\n        }\n    }\n    /**\n     * Disposes the resources held by the subscription. May, for instance, cancel\n     * an ongoing Observable execution or cancel any other type of work that\n     * started when the Subscription was created.\n     * @return {void}\n     */\n    Subscription.prototype.unsubscribe = function () {\n        var hasErrors = false;\n        var errors;\n        if (this.closed) {\n            return;\n        }\n        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n        this.closed = true;\n        this._parent = null;\n        this._parents = null;\n        // null out _subscriptions first so any child subscriptions that attempt\n        // to remove themselves from this subscription will noop\n        this._subscriptions = null;\n        var index = -1;\n        var len = _parents ? _parents.length : 0;\n        // if this._parent is null, then so is this._parents, and we\n        // don't have to remove ourselves from any parent subscriptions.\n        while (_parent) {\n            _parent.remove(this);\n            // if this._parents is null or index >= len,\n            // then _parent is set to null, and the loop exits\n            _parent = ++index < len && _parents[index] || null;\n        }\n        if (isFunction_1.isFunction(_unsubscribe)) {\n            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n            if (trial === errorObject_1.errorObject) {\n                hasErrors = true;\n                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?\n                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);\n            }\n        }\n        if (isArray_1.isArray(_subscriptions)) {\n            index = -1;\n            len = _subscriptions.length;\n            while (++index < len) {\n                var sub = _subscriptions[index];\n                if (isObject_1.isObject(sub)) {\n                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n                    if (trial === errorObject_1.errorObject) {\n                        hasErrors = true;\n                        errors = errors || [];\n                        var err = errorObject_1.errorObject.e;\n                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n                        }\n                        else {\n                            errors.push(err);\n                        }\n                    }\n                }\n            }\n        }\n        if (hasErrors) {\n            throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n        }\n    };\n    /**\n     * Adds a tear down to be called during the unsubscribe() of this\n     * Subscription.\n     *\n     * If the tear down being added is a subscription that is already\n     * unsubscribed, is the same reference `add` is being called on, or is\n     * `Subscription.EMPTY`, it will not be added.\n     *\n     * If this subscription is already in an `closed` state, the passed\n     * tear down logic will be executed immediately.\n     *\n     * @param {TeardownLogic} teardown The additional logic to execute on\n     * teardown.\n     * @return {Subscription} Returns the Subscription used or created to be\n     * added to the inner subscriptions list. This Subscription can be used with\n     * `remove()` to remove the passed teardown logic from the inner subscriptions\n     * list.\n     */\n    Subscription.prototype.add = function (teardown) {\n        if (!teardown || (teardown === Subscription.EMPTY)) {\n            return Subscription.EMPTY;\n        }\n        if (teardown === this) {\n            return this;\n        }\n        var subscription = teardown;\n        switch (typeof teardown) {\n            case 'function':\n                subscription = new Subscription(teardown);\n            case 'object':\n                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n                    return subscription;\n                }\n                else if (this.closed) {\n                    subscription.unsubscribe();\n                    return subscription;\n                }\n                else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n                    var tmp = subscription;\n                    subscription = new Subscription();\n                    subscription._subscriptions = [tmp];\n                }\n                break;\n            default:\n                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n        var subscriptions = this._subscriptions || (this._subscriptions = []);\n        subscriptions.push(subscription);\n        subscription._addParent(this);\n        return subscription;\n    };\n    /**\n     * Removes a Subscription from the internal list of subscriptions that will\n     * unsubscribe during the unsubscribe process of this Subscription.\n     * @param {Subscription} subscription The subscription to remove.\n     * @return {void}\n     */\n    Subscription.prototype.remove = function (subscription) {\n        var subscriptions = this._subscriptions;\n        if (subscriptions) {\n            var subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    };\n    Subscription.prototype._addParent = function (parent) {\n        var _a = this, _parent = _a._parent, _parents = _a._parents;\n        if (!_parent || _parent === parent) {\n            // If we don't have a parent, or the new parent is the same as the\n            // current parent, then set this._parent to the new parent.\n            this._parent = parent;\n        }\n        else if (!_parents) {\n            // If there's already one parent, but not multiple, allocate an Array to\n            // store the rest of the parent Subscriptions.\n            this._parents = [parent];\n        }\n        else if (_parents.indexOf(parent) === -1) {\n            // Only add the new parent to the _parents list if it's not already there.\n            _parents.push(parent);\n        }\n    };\n    Subscription.EMPTY = (function (empty) {\n        empty.closed = true;\n        return empty;\n    }(new Subscription()));\n    return Subscription;\n}());\nexports.Subscription = Subscription;\nfunction flattenUnsubscriptionErrors(errors) {\n    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);\n}\n//# sourceMappingURL=Subscription.js.map","\"use strict\";\nvar noop_1 = require('./noop');\n/* tslint:enable:max-line-length */\nfunction pipe() {\n    var fns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fns[_i - 0] = arguments[_i];\n    }\n    return pipeFromArray(fns);\n}\nexports.pipe = pipe;\n/* @internal */\nfunction pipeFromArray(fns) {\n    if (!fns) {\n        return noop_1.noop;\n    }\n    if (fns.length === 1) {\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce(function (prev, fn) { return fn(prev); }, input);\n    };\n}\nexports.pipeFromArray = pipeFromArray;\n//# sourceMappingURL=pipe.js.map","export const WorkerMessageTypes = Object.freeze({\n    CONNECT_WORKER : 'CONNECT_WORKER',\n    CONNECT_WORKER_SUCCESS : 'CONNECT_WORKER_SUCCESS',\n    CONNECT_WORKER_FAILED : 'CONNECT_WORKER_FAILED',\n\n    SET_WORKER_CONFIG : 'SET_WORKER_CONFIG',\n    WORKER_READY : 'WORKER_READY',\n\n    CONNECT_SOCKET : 'CONNECT_SOCKET',\n    CONNECT_SOCKET_SUCCESS : 'CONNECT_SOCKET_SUCCESS',\n    CONNECT_SOCKET_FAILED : 'CONNECT_SOCKET_FAILED',\n\n    SUBSCRIBE_DATA : 'SUBSCRIBE_DATA',\n    SUBSCRIBE_DATA_FAILED : 'SUBSCRIBE_DATA_FAILED'\n});\n\n\n","\nexport enum LogLevel {\n      ALL = 0,\n      TRACE = 1,\n      DEBUG = 2,\n      INFO = 3,\n      WARN = 4,\n      ERROR = 5,\n      FATAL = 6,\n      OFF = 7\n}\nexport interface LoggerStaticInfo {\n      appName: string;\n      user?: string;\n      region?: string;\n      env?: string;\n}\nexport interface LogOptions {\n      appLogLevel: LogLevel;\n      forcedLogLevel?: LogLevel;\n      logInterval: number;\n      appenders: AppenderOptions[];\n      logServer?: any;\n}\nexport interface AppenderOptions {\n      name: string;\n      format: string; // Text, json\n      pattern?: string;\n      path?: string;\n      logLevel?: LogLevel;\n      isDefferred?: boolean;\n}\n","\nexport class WorkerMessage {\n    type : string;\n    constructor(public payload?: any) {\n\n    }\n}\n\nexport class WorkerMessageBuilder {\n    static build(type: string,payload?: any) {\n        const message = new WorkerMessage(payload);\n        message.type = type;\n        return message;\n    }\n}\n","import { WorkerMessage, WorkerMessageTypes, WorkerMessageBuilder } from \"../config-models/index\";\n\n\n\nexport class WorkerAgent {\n  private static _instance: WorkerAgent = new WorkerAgent();\n\n  constructor() {\n    if (WorkerAgent._instance) {\n      throw new Error(\"Error: Instantiation failed: Use WorkerAgent.instance instead of new.\");\n    }\n    WorkerAgent._instance = this;\n  }\n\n  static get instance(): WorkerAgent {\n    return WorkerAgent._instance;\n  }\n\n  private context: any;\n\n  setContext(context: any, sendConnected: boolean = false) {\n    this.context = context;\n    if (sendConnected) {\n      this.dispatchMessage(WorkerMessageBuilder.build(WorkerMessageTypes.CONNECT_WORKER_SUCCESS));\n    }\n  }\n\n  onMessage(message: WorkerMessage) {\n    switch (message.type) {\n      case WorkerMessageTypes.CONNECT_WORKER:\n        this.context['name'] = message.payload.name;\n        this.dispatchMessage(WorkerMessageBuilder.build(WorkerMessageTypes.CONNECT_WORKER_SUCCESS));\n        break;\n      default:\n      // TODO: Send to SocketService\n    }\n  }\n  dispatchMessage(message: WorkerMessage) {\n    this.context.postMessage(message);\n  }\n}\n","import { LoggingEvent } from '../models/log-event';\nimport { AppenderOptions } from '../../fit-logger-core/index';\nimport { Appender } from './appender';\n\n\nexport class ServerAppender implements Appender {\n\n      constructor(private options: AppenderOptions) {\n      }\n      get name(): string {\n            return 'ajax';\n      }\n      writeLog(loggingEvent: LoggingEvent): void {\n            console.info(JSON.stringify(loggingEvent))\n      }\n      writeLogs(loggingEvent: LoggingEvent[]): void {\n            console.info(JSON.stringify(loggingEvent))\n      }\n      update(appenderOptions: AppenderOptions) : void {\n        this.options = appenderOptions;\n      }\n}\n","import { AppenderOptions, LogLevel } from '../../fit-logger-core/index';\nimport { Appender } from \"./appender\";\nimport { LoggingEvent } from \"../models/log-event\";\n\n\n\nexport class ConsoleAppender implements Appender {\n      get name(): string {\n            return 'console';\n      }\n      constructor(private options: AppenderOptions) {\n\n      }\n\n      writeLog(loggingEvent: LoggingEvent): void {\n            if (this.options.logLevel !== LogLevel.OFF && loggingEvent.level >= this.options.logLevel) {\n                  const message = this.getFormattedMessage(loggingEvent);\n                  switch (loggingEvent.level) {\n                        case LogLevel.DEBUG:\n                              console.debug(message);\n                              break;\n                        case LogLevel.ERROR:\n                        case LogLevel.FATAL:\n                              console.error(message);\n                              break;\n                        case LogLevel.INFO:\n                              console.info(message);\n                              break;\n                        default:\n                              console.info(message);\n                  }\n            }\n      }\n      writeLogs(loggingEvent: LoggingEvent[]): void {\n\n      }\n\n      update(appenderOptions: AppenderOptions): void {\n            this.options = appenderOptions;\n      }\n\n      private getFormattedMessage(loggingEvent: LoggingEvent): string {\n            return `[${loggingEvent.appName}-${loggingEvent.name}-${this.getFormattedTime(loggingEvent.timestamp)}] [${LogLevel[loggingEvent.level]}] => ${loggingEvent.message}`;\n      }\n      private getFormattedTime(timestamp: number): string {\n        const date = new Date(timestamp);\n        return `${date.getMonth()}-${date.getDate()}-${date.getFullYear()} ${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}.${date.getMilliseconds()}`;\n      }\n}\n","import { Appender } from './appender';\nimport { LoggingEvent } from '../models/log-event';\nimport { AppenderOptions } from '../../fit-logger-core/index';\n\n\n\nexport class WebWorkerAppender implements Appender {\n  private worker: SharedWorker.SharedWorker;\n  private isWorkerReady = false;\n\n  constructor(private options: AppenderOptions) {\n\n  }\n\n  get name(): string {\n    return 'worker';\n  }\n  writeLog(loggingEvent: LoggingEvent): void {\n    // throw new Error(\"Method not implemented.\");\n  }\n  writeLogs(loggingEvent: LoggingEvent[]): void {\n    if (this.isWorkerReady) {\n      this.worker.port.postMessage({ type: 'LOG_MESSAGE', payload: loggingEvent });\n    }\n  }\n\n  update(appenderOptions: AppenderOptions): void {\n    this.dispose();\n    this.options = appenderOptions;\n    this.worker = new SharedWorker(appenderOptions.path, 'Logger-Worker23');\n    this.worker.port.addEventListener('error', this.onWorkerError.bind(this));\n    this.worker.port.addEventListener('message', this.onWorkerMessage.bind(this));\n    this.worker.port.start();\n  }\n\n  private onWorkerError(errorEvt: ErrorEvent) {\n    console.error(errorEvt);\n  }\n  private onWorkerMessage(evt: MessageEvent) {\n    if(evt.data.type === 'WORKER_CONNECTED') {\n      this.isWorkerReady = true;\n    }\n    console.info(evt.data);\n  }\n  private dispose(): void {\n    if (this.worker) {\n      this.isWorkerReady = false;\n      this.worker.port.removeEventListener('error', this.onWorkerError.bind(this));\n      this.worker.port.removeEventListener('message', this.onWorkerMessage.bind(this));\n      this.worker.port.close();\n    }\n  }\n}\n","import { ServerAppender } from './server.appender';\nimport { AppenderOptions, LogLevel } from '../../fit-logger-core/index';\nimport { ConsoleAppender } from './console.appender';\nimport { Appender } from './appender';\nimport { WebWorkerAppender } from './worker.appender';\n\n\nexport class AppenderRepository {\n      private static _instance = new AppenderRepository();\n      private appenderMap: Map<string, Appender> = new Map();\n\n      constructor() {\n            if (AppenderRepository._instance) {\n                  throw new Error(\"Error: Instantiation failed: Use AppenderRepository.instance instead of new.\");\n            }\n            AppenderRepository._instance = this;\n            this.appenderMap.set('console', new ConsoleAppender({\n                  name: 'console',\n                  format: 'text',\n                  logLevel: LogLevel.INFO\n            }));\n            this.appenderMap.set('server', new ServerAppender({\n                  name: 'server',\n                  format: 'json',\n                  logLevel: LogLevel.INFO,\n                  isDefferred: true\n            }));\n            this.appenderMap.set('worker', new WebWorkerAppender({\n                  name: 'worker',\n                  format: 'json',\n                  logLevel: LogLevel.INFO,\n                  isDefferred: true,\n                  path: 'assets/worker/socket-logger.js'\n            }));\n      }\n\n      getAppender(name: string): Appender {\n            if (this.appenderMap.has(name)) {\n                  return this.appenderMap.get(name);\n            }\n            throw new Error(`LogAppender : ${name} is not found`);\n      }\n      static get instance(): AppenderRepository {\n            return AppenderRepository._instance;\n      }\n}\n","\"use strict\";\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\nvar __window = typeof window !== 'undefined' && window;\nvar __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nvar __global = typeof global !== 'undefined' && global;\nvar _root = __window || __global || __self;\nexports.root = _root;\n// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.\n// This is needed when used with angular/tsickle which inserts a goog.module statement.\n// Wrap in IIFE\n(function () {\n    if (!_root) {\n        throw new Error('RxJS could not find any global context (window, self, global)');\n    }\n})();\n//# sourceMappingURL=root.js.map","\"use strict\";\nfunction isFunction(x) {\n    return typeof x === 'function';\n}\nexports.isFunction = isFunction;\n//# sourceMappingURL=isFunction.js.map","\"use strict\";\nexports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n//# sourceMappingURL=isArray.js.map","\"use strict\";\nfunction isObject(x) {\n    return x != null && typeof x === 'object';\n}\nexports.isObject = isObject;\n//# sourceMappingURL=isObject.js.map","\"use strict\";\n// typeof any so that it we don't have to cast when comparing a result to the error object\nexports.errorObject = { e: {} };\n//# sourceMappingURL=errorObject.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nvar UnsubscriptionError = (function (_super) {\n    __extends(UnsubscriptionError, _super);\n    function UnsubscriptionError(errors) {\n        _super.call(this);\n        this.errors = errors;\n        var err = Error.call(this, errors ?\n            errors.length + \" errors occurred during unsubscription:\\n  \" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n  ') : '');\n        this.name = err.name = 'UnsubscriptionError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return UnsubscriptionError;\n}(Error));\nexports.UnsubscriptionError = UnsubscriptionError;\n//# sourceMappingURL=UnsubscriptionError.js.map","\"use strict\";\nexports.empty = {\n    closed: true,\n    next: function (value) { },\n    error: function (err) { throw err; },\n    complete: function () { }\n};\n//# sourceMappingURL=Observer.js.map","\"use strict\";\nvar root_1 = require('../util/root');\nvar Symbol = root_1.root.Symbol;\nexports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n    Symbol.for('rxSubscriber') : '@@rxSubscriber';\n/**\n * @deprecated use rxSubscriber instead\n */\nexports.$$rxSubscriber = exports.rxSubscriber;\n//# sourceMappingURL=rxSubscriber.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isFunction_1 = require('./util/isFunction');\nvar Subscription_1 = require('./Subscription');\nvar Observer_1 = require('./Observer');\nvar rxSubscriber_1 = require('./symbol/rxSubscriber');\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nvar Subscriber = (function (_super) {\n    __extends(Subscriber, _super);\n    /**\n     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n     * defined Observer or a `next` callback function.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     */\n    function Subscriber(destinationOrNext, error, complete) {\n        _super.call(this);\n        this.syncErrorValue = null;\n        this.syncErrorThrown = false;\n        this.syncErrorThrowable = false;\n        this.isStopped = false;\n        switch (arguments.length) {\n            case 0:\n                this.destination = Observer_1.empty;\n                break;\n            case 1:\n                if (!destinationOrNext) {\n                    this.destination = Observer_1.empty;\n                    break;\n                }\n                if (typeof destinationOrNext === 'object') {\n                    if (destinationOrNext instanceof Subscriber) {\n                        this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;\n                        this.destination = destinationOrNext;\n                        this.destination.add(this);\n                    }\n                    else {\n                        this.syncErrorThrowable = true;\n                        this.destination = new SafeSubscriber(this, destinationOrNext);\n                    }\n                    break;\n                }\n            default:\n                this.syncErrorThrowable = true;\n                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n                break;\n        }\n    }\n    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };\n    /**\n     * A static factory for a Subscriber, given a (potentially partial) definition\n     * of an Observer.\n     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n     * Observer represented by the given arguments.\n     */\n    Subscriber.create = function (next, error, complete) {\n        var subscriber = new Subscriber(next, error, complete);\n        subscriber.syncErrorThrowable = false;\n        return subscriber;\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `next` from\n     * the Observable, with a value. The Observable may call this method 0 or more\n     * times.\n     * @param {T} [value] The `next` value.\n     * @return {void}\n     */\n    Subscriber.prototype.next = function (value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `error` from\n     * the Observable, with an attached {@link Error}. Notifies the Observer that\n     * the Observable has experienced an error condition.\n     * @param {any} [err] The `error` exception.\n     * @return {void}\n     */\n    Subscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive a valueless notification of type\n     * `complete` from the Observable. Notifies the Observer that the Observable\n     * has finished sending push-based notifications.\n     * @return {void}\n     */\n    Subscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.isStopped = true;\n        _super.prototype.unsubscribe.call(this);\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    };\n    Subscriber.prototype._complete = function () {\n        this.destination.complete();\n        this.unsubscribe();\n    };\n    Subscriber.prototype._unsubscribeAndRecycle = function () {\n        var _a = this, _parent = _a._parent, _parents = _a._parents;\n        this._parent = null;\n        this._parents = null;\n        this.unsubscribe();\n        this.closed = false;\n        this.isStopped = false;\n        this._parent = _parent;\n        this._parents = _parents;\n        return this;\n    };\n    return Subscriber;\n}(Subscription_1.Subscription));\nexports.Subscriber = Subscriber;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SafeSubscriber = (function (_super) {\n    __extends(SafeSubscriber, _super);\n    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n        _super.call(this);\n        this._parentSubscriber = _parentSubscriber;\n        var next;\n        var context = this;\n        if (isFunction_1.isFunction(observerOrNext)) {\n            next = observerOrNext;\n        }\n        else if (observerOrNext) {\n            next = observerOrNext.next;\n            error = observerOrNext.error;\n            complete = observerOrNext.complete;\n            if (observerOrNext !== Observer_1.empty) {\n                context = Object.create(observerOrNext);\n                if (isFunction_1.isFunction(context.unsubscribe)) {\n                    this.add(context.unsubscribe.bind(context));\n                }\n                context.unsubscribe = this.unsubscribe.bind(this);\n            }\n        }\n        this._context = context;\n        this._next = next;\n        this._error = error;\n        this._complete = complete;\n    }\n    SafeSubscriber.prototype.next = function (value) {\n        if (!this.isStopped && this._next) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (!_parentSubscriber.syncErrorThrowable) {\n                this.__tryOrUnsub(this._next, value);\n            }\n            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (this._error) {\n                if (!_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._error, err);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, this._error, err);\n                    this.unsubscribe();\n                }\n            }\n            else if (!_parentSubscriber.syncErrorThrowable) {\n                this.unsubscribe();\n                throw err;\n            }\n            else {\n                _parentSubscriber.syncErrorValue = err;\n                _parentSubscriber.syncErrorThrown = true;\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.complete = function () {\n        var _this = this;\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (this._complete) {\n                var wrappedComplete = function () { return _this._complete.call(_this._context); };\n                if (!_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(wrappedComplete);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n                    this.unsubscribe();\n                }\n            }\n            else {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            this.unsubscribe();\n            throw err;\n        }\n    };\n    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            parent.syncErrorValue = err;\n            parent.syncErrorThrown = true;\n            return true;\n        }\n        return false;\n    };\n    SafeSubscriber.prototype._unsubscribe = function () {\n        var _parentSubscriber = this._parentSubscriber;\n        this._context = null;\n        this._parentSubscriber = null;\n        _parentSubscriber.unsubscribe();\n    };\n    return SafeSubscriber;\n}(Subscriber));\n//# sourceMappingURL=Subscriber.js.map","\"use strict\";\nvar Subscriber_1 = require('../Subscriber');\nvar rxSubscriber_1 = require('../symbol/rxSubscriber');\nvar Observer_1 = require('../Observer');\nfunction toSubscriber(nextOrObserver, error, complete) {\n    if (nextOrObserver) {\n        if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n            return nextOrObserver;\n        }\n        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {\n            return nextOrObserver[rxSubscriber_1.rxSubscriber]();\n        }\n    }\n    if (!nextOrObserver && !error && !complete) {\n        return new Subscriber_1.Subscriber(Observer_1.empty);\n    }\n    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n}\nexports.toSubscriber = toSubscriber;\n//# sourceMappingURL=toSubscriber.js.map","\"use strict\";\nvar root_1 = require('../util/root');\nfunction getSymbolObservable(context) {\n    var $$observable;\n    var Symbol = context.Symbol;\n    if (typeof Symbol === 'function') {\n        if (Symbol.observable) {\n            $$observable = Symbol.observable;\n        }\n        else {\n            $$observable = Symbol('observable');\n            Symbol.observable = $$observable;\n        }\n    }\n    else {\n        $$observable = '@@observable';\n    }\n    return $$observable;\n}\nexports.getSymbolObservable = getSymbolObservable;\nexports.observable = getSymbolObservable(root_1.root);\n/**\n * @deprecated use observable instead\n */\nexports.$$observable = exports.observable;\n//# sourceMappingURL=observable.js.map","\"use strict\";\n/* tslint:disable:no-empty */\nfunction noop() { }\nexports.noop = noop;\n//# sourceMappingURL=noop.js.map","\"use strict\";\nvar root_1 = require('./util/root');\nvar toSubscriber_1 = require('./util/toSubscriber');\nvar observable_1 = require('./symbol/observable');\nvar pipe_1 = require('./util/pipe');\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nvar Observable = (function () {\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is called when the Observable is\n     * initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or\n     * `complete` can be called to notify of a successful completion.\n     */\n    function Observable(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    /**\n     * Creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @return {Observable} a new observable with the Operator applied\n     */\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    /**\n     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n     *\n     * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n     *\n     * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is\n     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling\n     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n     * thought.\n     *\n     * Apart from starting the execution of an Observable, this method allows you to listen for values\n     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n     * following ways.\n     *\n     * The first way is creating an object that implements {@link Observer} interface. It should have methods\n     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will\n     * be left uncaught.\n     *\n     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent\n     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,\n     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n     *\n     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean\n     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n     *\n     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n     * It is an Observable itself that decides when these functions will be called. For example {@link of}\n     * by default emits all its values synchronously. Always check documentation for how given Observable\n     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.\n     *\n     * @example <caption>Subscribe with an Observer</caption>\n     * const sumObserver = {\n     *   sum: 0,\n     *   next(value) {\n     *     console.log('Adding: ' + value);\n     *     this.sum = this.sum + value;\n     *   },\n     *   error() { // We actually could just remove this method,\n     *   },        // since we do not really care about errors right now.\n     *   complete() {\n     *     console.log('Sum equals: ' + this.sum);\n     *   }\n     * };\n     *\n     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n     * .subscribe(sumObserver);\n     *\n     * // Logs:\n     * // \"Adding: 1\"\n     * // \"Adding: 2\"\n     * // \"Adding: 3\"\n     * // \"Sum equals: 6\"\n     *\n     *\n     * @example <caption>Subscribe with functions</caption>\n     * let sum = 0;\n     *\n     * Rx.Observable.of(1, 2, 3)\n     * .subscribe(\n     *   function(value) {\n     *     console.log('Adding: ' + value);\n     *     sum = sum + value;\n     *   },\n     *   undefined,\n     *   function() {\n     *     console.log('Sum equals: ' + sum);\n     *   }\n     * );\n     *\n     * // Logs:\n     * // \"Adding: 1\"\n     * // \"Adding: 2\"\n     * // \"Adding: 3\"\n     * // \"Sum equals: 6\"\n     *\n     *\n     * @example <caption>Cancel a subscription</caption>\n     * const subscription = Rx.Observable.interval(1000).subscribe(\n     *   num => console.log(num),\n     *   undefined,\n     *   () => console.log('completed!') // Will not be called, even\n     * );                                // when cancelling subscription\n     *\n     *\n     * setTimeout(() => {\n     *   subscription.unsubscribe();\n     *   console.log('unsubscribed!');\n     * }, 2500);\n     *\n     * // Logs:\n     * // 0 after 1s\n     * // 1 after 2s\n     * // \"unsubscribed!\" after 2.5s\n     *\n     *\n     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n     *  Observable.\n     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n     *  the error will be thrown as unhandled.\n     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n     * @return {ISubscription} a subscription reference to the registered handlers\n     * @method subscribe\n     */\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var operator = this.operator;\n        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n        if (operator) {\n            operator.call(sink, this.source);\n        }\n        else {\n            sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));\n        }\n        if (sink.syncErrorThrowable) {\n            sink.syncErrorThrowable = false;\n            if (sink.syncErrorThrown) {\n                throw sink.syncErrorValue;\n            }\n        }\n        return sink;\n    };\n    Observable.prototype._trySubscribe = function (sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            sink.syncErrorThrown = true;\n            sink.syncErrorValue = err;\n            sink.error(err);\n        }\n    };\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n     * @return {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    Observable.prototype.forEach = function (next, PromiseCtor) {\n        var _this = this;\n        if (!PromiseCtor) {\n            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                PromiseCtor = root_1.root.Rx.config.Promise;\n            }\n            else if (root_1.root.Promise) {\n                PromiseCtor = root_1.root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error('no Promise impl found');\n        }\n        return new PromiseCtor(function (resolve, reject) {\n            // Must be declared in a separate statement to avoid a RefernceError when\n            // accessing subscription below in the closure due to Temporal Dead Zone.\n            var subscription;\n            subscription = _this.subscribe(function (value) {\n                if (subscription) {\n                    // if there is a subscription, then we can surmise\n                    // the next handling is asynchronous. Any errors thrown\n                    // need to be rejected explicitly and unsubscribe must be\n                    // called manually\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscription.unsubscribe();\n                    }\n                }\n                else {\n                    // if there is NO subscription, then we're getting a nexted\n                    // value synchronously during subscription. We can just call it.\n                    // If it errors, Observable's `subscribe` will ensure the\n                    // unsubscription logic is called, then synchronously rethrow the error.\n                    // After that, Promise will trap the error and send it\n                    // down the rejection path.\n                    next(value);\n                }\n            }, reject, resolve);\n        });\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        return this.source.subscribe(subscriber);\n    };\n    /**\n     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n     * @method Symbol.observable\n     * @return {Observable} this instance of the observable\n     */\n    Observable.prototype[observable_1.observable] = function () {\n        return this;\n    };\n    /* tslint:enable:max-line-length */\n    /**\n     * Used to stitch together functional operators into a chain.\n     * @method pipe\n     * @return {Observable} the Observable result of all of the operators having\n     * been called in the order they were passed in.\n     *\n     * @example\n     *\n     * import { map, filter, scan } from 'rxjs/operators';\n     *\n     * Rx.Observable.interval(1000)\n     *   .pipe(\n     *     filter(x => x % 2 === 0),\n     *     map(x => x + x),\n     *     scan((acc, x) => acc + x)\n     *   )\n     *   .subscribe(x => console.log(x))\n     */\n    Observable.prototype.pipe = function () {\n        var operations = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            operations[_i - 0] = arguments[_i];\n        }\n        if (operations.length === 0) {\n            return this;\n        }\n        return pipe_1.pipeFromArray(operations)(this);\n    };\n    /* tslint:enable:max-line-length */\n    Observable.prototype.toPromise = function (PromiseCtor) {\n        var _this = this;\n        if (!PromiseCtor) {\n            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                PromiseCtor = root_1.root.Rx.config.Promise;\n            }\n            else if (root_1.root.Promise) {\n                PromiseCtor = root_1.root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error('no Promise impl found');\n        }\n        return new PromiseCtor(function (resolve, reject) {\n            var value;\n            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });\n        });\n    };\n    // HACK: Since TypeScript inherits static properties too, we have to\n    // fight against TypeScript here so Subject can have a different static create signature\n    /**\n     * Creates a new cold Observable by calling the Observable constructor\n     * @static true\n     * @owner Observable\n     * @method create\n     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n     * @return {Observable} a new cold observable\n     */\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\nexports.Observable = Observable;\n//# sourceMappingURL=Observable.js.map","\"use strict\";\nvar isArray_1 = require('../util/isArray');\nfunction isNumeric(val) {\n    // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n    // subtraction forces infinities to NaN\n    // adding 1 corrects loss of precision from parseFloat (#15100)\n    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;\n}\nexports.isNumeric = isNumeric;\n;\n//# sourceMappingURL=isNumeric.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = require('../Subscription');\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nvar Action = (function (_super) {\n    __extends(Action, _super);\n    function Action(scheduler, work) {\n        _super.call(this);\n    }\n    /**\n     * Schedules this action on its parent Scheduler for execution. May be passed\n     * some context object, `state`. May happen at some point in the future,\n     * according to the `delay` parameter, if specified.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler.\n     * @return {void}\n     */\n    Action.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        return this;\n    };\n    return Action;\n}(Subscription_1.Subscription));\nexports.Action = Action;\n//# sourceMappingURL=Action.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = require('../util/root');\nvar Action_1 = require('./Action');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AsyncAction = (function (_super) {\n    __extends(AsyncAction, _super);\n    function AsyncAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.pending = false;\n    }\n    AsyncAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (this.closed) {\n            return this;\n        }\n        // Always replace the current state with the new state.\n        this.state = state;\n        // Set the pending flag indicating that this action has been scheduled, or\n        // has recursively rescheduled itself.\n        this.pending = true;\n        var id = this.id;\n        var scheduler = this.scheduler;\n        //\n        // Important implementation note:\n        //\n        // Actions only execute once by default, unless rescheduled from within the\n        // scheduled callback. This allows us to implement single and repeat\n        // actions via the same code path, without adding API surface area, as well\n        // as mimic traditional recursion but across asynchronous boundaries.\n        //\n        // However, JS runtimes and timers distinguish between intervals achieved by\n        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n        // serial `setTimeout` calls can be individually delayed, which delays\n        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n        // guarantee the interval callback will be invoked more precisely to the\n        // interval period, regardless of load.\n        //\n        // Therefore, we use `setInterval` to schedule single and repeat actions.\n        // If the action reschedules itself with the same delay, the interval is not\n        // canceled. If the action doesn't reschedule, or reschedules with a\n        // different delay, the interval will be canceled after scheduled callback\n        // execution.\n        //\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.delay = delay;\n        // If this action has already an async Id, don't request a new one.\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    };\n    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n    };\n    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If this action is rescheduled with the same delay time, don't clear the interval id.\n        if (delay !== null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        // Otherwise, if the action's delay time is different from the current delay,\n        // or the action has been rescheduled before it's executed, clear the interval id\n        return root_1.root.clearInterval(id) && undefined || undefined;\n    };\n    /**\n     * Immediately executes this action and the `work` it contains.\n     * @return {any}\n     */\n    AsyncAction.prototype.execute = function (state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        var error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            // Dequeue if the action didn't reschedule itself. Don't call\n            // unsubscribe(), because the action could reschedule later.\n            // For example:\n            // ```\n            // scheduler.schedule(function doWork(counter) {\n            //   /* ... I'm a busy worker bee ... */\n            //   var originalAction = this;\n            //   /* wait 100ms before rescheduling the action */\n            //   setTimeout(function () {\n            //     originalAction.schedule(counter + 1);\n            //   }, 100);\n            // }, 1000);\n            // ```\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    };\n    AsyncAction.prototype._execute = function (state, delay) {\n        var errored = false;\n        var errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    };\n    AsyncAction.prototype._unsubscribe = function () {\n        var id = this.id;\n        var scheduler = this.scheduler;\n        var actions = scheduler.actions;\n        var index = actions.indexOf(this);\n        this.work = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n        this.delay = null;\n    };\n    return AsyncAction;\n}(Action_1.Action));\nexports.AsyncAction = AsyncAction;\n//# sourceMappingURL=AsyncAction.js.map","\"use strict\";\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n */\nvar Scheduler = (function () {\n    function Scheduler(SchedulerAction, now) {\n        if (now === void 0) { now = Scheduler.now; }\n        this.SchedulerAction = SchedulerAction;\n        this.now = now;\n    }\n    /**\n     * Schedules a function, `work`, for execution. May happen at some point in\n     * the future, according to the `delay` parameter, if specified. May be passed\n     * some context object, `state`, which will be passed to the `work` function.\n     *\n     * The given arguments will be processed an stored as an Action object in a\n     * queue of actions.\n     *\n     * @param {function(state: ?T): ?Subscription} work A function representing a\n     * task, or some unit of work to be executed by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler itself.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @return {Subscription} A subscription in order to be able to unsubscribe\n     * the scheduled work.\n     */\n    Scheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) { delay = 0; }\n        return new this.SchedulerAction(this, work).schedule(state, delay);\n    };\n    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };\n    return Scheduler;\n}());\nexports.Scheduler = Scheduler;\n//# sourceMappingURL=Scheduler.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Scheduler_1 = require('../Scheduler');\nvar AsyncScheduler = (function (_super) {\n    __extends(AsyncScheduler, _super);\n    function AsyncScheduler() {\n        _super.apply(this, arguments);\n        this.actions = [];\n        /**\n         * A flag to indicate whether the Scheduler is currently executing a batch of\n         * queued actions.\n         * @type {boolean}\n         */\n        this.active = false;\n        /**\n         * An internal ID used to track the latest asynchronous task such as those\n         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n         * others.\n         * @type {any}\n         */\n        this.scheduled = undefined;\n    }\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift()); // exhaust the scheduler queue\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler_1.Scheduler));\nexports.AsyncScheduler = AsyncScheduler;\n//# sourceMappingURL=AsyncScheduler.js.map","\"use strict\";\nvar AsyncAction_1 = require('./AsyncAction');\nvar AsyncScheduler_1 = require('./AsyncScheduler');\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asap} scheduler.\n *\n * @example <caption>Use async scheduler to delay task</caption>\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n *\n *\n * @example <caption>Use async scheduler to repeat task in intervals</caption>\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\nexports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);\n//# sourceMappingURL=async.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = require('../util/isNumeric');\nvar Observable_1 = require('../Observable');\nvar async_1 = require('../scheduler/async');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar IntervalObservable = (function (_super) {\n    __extends(IntervalObservable, _super);\n    function IntervalObservable(period, scheduler) {\n        if (period === void 0) { period = 0; }\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        _super.call(this);\n        this.period = period;\n        this.scheduler = scheduler;\n        if (!isNumeric_1.isNumeric(period) || period < 0) {\n            this.period = 0;\n        }\n        if (!scheduler || typeof scheduler.schedule !== 'function') {\n            this.scheduler = async_1.async;\n        }\n    }\n    /**\n     * Creates an Observable that emits sequential numbers every specified\n     * interval of time, on a specified IScheduler.\n     *\n     * <span class=\"informal\">Emits incremental numbers periodically in time.\n     * </span>\n     *\n     * <img src=\"./img/interval.png\" width=\"100%\">\n     *\n     * `interval` returns an Observable that emits an infinite sequence of\n     * ascending integers, with a constant interval of time of your choosing\n     * between those emissions. The first emission is not sent immediately, but\n     * only after the first period has passed. By default, this operator uses the\n     * `async` IScheduler to provide a notion of time, but you may pass any\n     * IScheduler to it.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>\n     * var numbers = Rx.Observable.interval(1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link timer}\n     * @see {@link delay}\n     *\n     * @param {number} [period=0] The interval size in milliseconds (by default)\n     * or the time unit determined by the scheduler's clock.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a sequential number each time\n     * interval.\n     * @static true\n     * @name interval\n     * @owner Observable\n     */\n    IntervalObservable.create = function (period, scheduler) {\n        if (period === void 0) { period = 0; }\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return new IntervalObservable(period, scheduler);\n    };\n    IntervalObservable.dispatch = function (state) {\n        var index = state.index, subscriber = state.subscriber, period = state.period;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        state.index += 1;\n        this.schedule(state, period);\n    };\n    IntervalObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var period = this.period;\n        var scheduler = this.scheduler;\n        subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {\n            index: index, subscriber: subscriber, period: period\n        }));\n    };\n    return IntervalObservable;\n}(Observable_1.Observable));\nexports.IntervalObservable = IntervalObservable;\n//# sourceMappingURL=IntervalObservable.js.map","\"use strict\";\nvar IntervalObservable_1 = require('./IntervalObservable');\nexports.interval = IntervalObservable_1.IntervalObservable.create;\n//# sourceMappingURL=interval.js.map","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar interval_1 = require('../../observable/interval');\nObservable_1.Observable.interval = interval_1.interval;\n//# sourceMappingURL=interval.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nfunction filter(predicate, thisArg) {\n    return function filterOperatorFunction(source) {\n        return source.lift(new FilterOperator(predicate, thisArg));\n    };\n}\nexports.filter = filter;\nvar FilterOperator = (function () {\n    function FilterOperator(predicate, thisArg) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n    }\n    FilterOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n    };\n    return FilterOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FilterSubscriber = (function (_super) {\n    __extends(FilterSubscriber, _super);\n    function FilterSubscriber(destination, predicate, thisArg) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.count = 0;\n    }\n    // the try catch block below is left specifically for\n    // optimization and perf reasons. a tryCatcher is not necessary here.\n    FilterSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.destination.next(value);\n        }\n    };\n    return FilterSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=filter.js.map","\"use strict\";\nvar filter_1 = require('../operators/filter');\n/* tslint:enable:max-line-length */\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nfunction filter(predicate, thisArg) {\n    return filter_1.filter(predicate, thisArg)(this);\n}\nexports.filter = filter;\n//# sourceMappingURL=filter.js.map","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar filter_1 = require('../../operator/filter');\nObservable_1.Observable.prototype.filter = filter_1.filter;\n//# sourceMappingURL=filter.js.map","import { Observable } from 'rxjs/Observable';\nimport { Subscription } from 'rxjs/Subscription';\nimport { LoggingEvent } from '../models/log-event';\nimport { Appender } from '../appenders/appender';\nimport 'rxjs/add/operator/filter';\nimport 'rxjs/add/observable/interval';\n\n\nexport abstract class LogWriter {\n      protected appenders: Map<string, Appender> = new Map();\n      abstract addLogEntry(logEvent: LoggingEvent): void;\n      addAppender(appender: Appender): void {\n            if (!this.appenders.has(appender.name)) {\n                  this.appenders.set(appender.name, appender);\n            }\n      }\n      static getImmediateLogWriter(): LogWriter {\n            return new ImmediateLogWriter();\n      }\n      static getDefferredWriter(delay: number): LogWriter {\n            return new DefferredLogger(delay);\n      }\n}\n\nclass ImmediateLogWriter extends LogWriter {\n\n      constructor() {\n            super();\n      }\n\n      addLogEntry(logEvent: LoggingEvent): void {\n            this.appenders.forEach((appender, key) => {\n                  appender.writeLog(logEvent);\n            });\n      }\n}\n\nclass DefferredLogger extends LogWriter {\n      private logEvents: LoggingEvent[] = [];\n      private subscription: Subscription;\n\n      constructor(private delay: number) {\n            super();\n            Observable.interval(delay)\n                  .filter(() => this.logEvents.length > 0)\n                  .subscribe(this.writeEvents.bind(this));\n      }\n      addLogEntry(logEvent: LoggingEvent): void {\n\n            this.logEvents.push(logEvent);\n      }\n      private writeEvents() {\n            this.appenders.forEach((appender, key) => {\n                  appender.writeLogs(this.logEvents);\n                  this.logEvents = [];\n            });\n      }\n}\n","import { AppenderRepository, Appender } from '../appenders/index';\nimport { LogLevel, LogOptions, LoggerStaticInfo } from \"../../fit-logger-core/index\";\nimport { LoggingEvent } from '../models/log-event';\nimport { Observable } from \"rxjs/Observable\";\nimport 'rxjs/add/observable/interval';\nimport { Subscription } from \"rxjs/Subscription\";\nimport { LogWriter } from './log.writer';\n\n\nexport class LoggingController {\n      private static _instance = new LoggingController();\n      private immedWriter = LogWriter.getImmediateLogWriter();\n      private defLogWriter: LogWriter;\n      private _staticInfo: LoggerStaticInfo = { appName: \"\" };\n      private _logOptions: LogOptions;\n\n      constructor() {\n            if (LoggingController._instance) {\n                  throw new Error(\"Error: Instantiation failed: Use LoggingStore.instance instead of new.\");\n            }\n            LoggingController._instance = this;\n      }\n\n      public initialize(loggerStaticInfo: LoggerStaticInfo, options?: LogOptions) {\n            this.resolveStaticInfo(loggerStaticInfo);\n            this._logOptions = options || this._logOptions || this.getDefaultOptions();\n            this._logOptions.appenders.forEach(appenderOptions => {\n                  if (appenderOptions.isDefferred) {\n                        const appender = AppenderRepository.instance.getAppender(appenderOptions.name);\n                        const delay = this._logOptions.logInterval || 10000;\n                        this.defLogWriter = this.defLogWriter || LogWriter.getDefferredWriter(delay);\n                        appender.update(appenderOptions);\n                        this.defLogWriter.addAppender(appender);\n                  } else {\n                        const appender = AppenderRepository.instance.getAppender(appenderOptions.name);\n                        appender.update(appenderOptions);\n                        this.immedWriter.addAppender(appender);\n                  }\n            });\n\n      }\n      public enqueue(logEvent: LoggingEvent): void {\n            logEvent.appName = this._staticInfo.appName;\n            logEvent.user = this._staticInfo.user;\n            logEvent.region = this._staticInfo.region;\n            logEvent.env = this._staticInfo.env;\n\n            this.immedWriter.addLogEntry(logEvent);\n            if (this.defLogWriter) {\n                  this.defLogWriter.addLogEntry(logEvent);\n            }\n      }\n\n      private resolveStaticInfo(staticInfo: LoggerStaticInfo) {\n            this._staticInfo.appName = this._staticInfo.appName || staticInfo.appName;\n            this._staticInfo.user = this._staticInfo.user || staticInfo.user;\n            this._staticInfo.env = this._staticInfo.env || staticInfo.env;\n            this._staticInfo.region = this._staticInfo.region || staticInfo.region;\n      }\n      private getDefaultOptions(): LogOptions {\n            return {\n                  appLogLevel: LogLevel.ALL,\n                  logInterval: 10000,\n                  appenders: [{\n                        name: 'console',\n                        format: 'text',\n                        logLevel: LogLevel.ALL\n                  }]\n            };\n      }\n      static get instance(): LoggingController {\n            return LoggingController._instance;\n      }\n}\n","import { LogLevel } from '../../fit-logger-core/index';\n\n\nexport class LoggingEvent {\n  appName : string;\n  user: string;\n  region : string;\n  env : string;\n  name : string;\n  groupName : string;\n  timestamp : number;\n  level : LogLevel;\n  message: string;\n}\n","import { ApplicationLogger, LogLevel } from '../../fit-logger-core/index';\nimport { LoggingEvent } from '../models/log-event';\nimport { LoggingController } from '../logwriters/logging.controller';\n\n\nexport class Logger implements ApplicationLogger {\n  private moduleLogLevel: LogLevel;\n  private timer = new Map<string, number>();\n\n  constructor(private loggerName: string, private level?: LogLevel) {\n    this.moduleLogLevel = level ? level : LogLevel.ALL;\n  }\n\n  log(level: LogLevel, params: any[]): void {\n    if (level >= this.moduleLogLevel) {\n      this.buildLoggingEvent(level, params);\n    }\n  }\n  trace(...messages: any[]): void {\n    if (this.moduleLogLevel >= LogLevel.TRACE) {\n      this.buildLoggingEvent(LogLevel.TRACE, messages);\n    }\n  }\n  debug(...messages: any[]): void {\n    if (LogLevel.DEBUG >= this.moduleLogLevel) {\n      this.buildLoggingEvent(LogLevel.DEBUG, messages);\n    }\n  }\n  info(...messages: any[]): void {\n    if (LogLevel.INFO >= this.moduleLogLevel) {\n      this.buildLoggingEvent(LogLevel.INFO, messages);\n    }\n  }\n  warn(...messages: any[]): void {\n    if (LogLevel.WARN >= this.moduleLogLevel) {\n      this.buildLoggingEvent(LogLevel.WARN, messages);\n    }\n  }\n  error(...messages: any[]): void {\n    if (LogLevel.ERROR >= this.moduleLogLevel) {\n      this.buildLoggingEvent(LogLevel.ERROR, messages);\n    }\n  }\n  fatal(...messages: any[]): void {\n    if (LogLevel.FATAL >= this.moduleLogLevel) {\n      this.buildLoggingEvent(LogLevel.FATAL, messages);\n    }\n  }\n  group(name: string, initiallyExpanded?: boolean): void {\n    // this.buildLoggingEvent(LogLevel.TRACE,undefined,messages);\n  }\n  groupEnd(): void {\n    // this.buildLoggingEvent(LogLevel.TRACE,undefined,messages);\n  }\n  time(name: string, level?: LogLevel): void {\n    if (LogLevel.INFO >= this.moduleLogLevel) {\n      if (!this.timer.has(name)) {\n        this.timer.set(name, Date.now());\n      }\n    }\n  }\n  timeEnd(name: string): void {\n    if (LogLevel.INFO >= this.moduleLogLevel) {\n      const startTime = this.timer.get(name);\n      const message = `Time taken by [${name}] : ${(Date.now()-startTime)/1000} seconds`;\n      this.timer.delete(name);\n      this.buildLoggingEvent(LogLevel.INFO,  [message]);\n    }\n  }\n  assert(expr: any): void {\n    // this.buildLoggingEvent(LogLevel.TRACE,undefined,messages);\n  }\n  get name(): string {\n    return this.loggerName;\n  }\n\n\n  private buildLoggingEvent(level: LogLevel, messages: any[]) {\n    const loggingEvent = new LoggingEvent();\n    loggingEvent.name = this.name;\n    loggingEvent.level = level;\n    loggingEvent.timestamp = Date.now();\n    loggingEvent.message = this.buildMessage(messages);\n    LoggingController.instance.enqueue(loggingEvent);\n  }\n  private buildMessage(messages: any[]): string {\n    let message = \"\";\n    messages.forEach(msg=> {\n      if(msg instanceof  Error) {\n        message += `${msg.stack}, `;\n      } else if(typeof msg === \"object\") {\n        message += `${JSON.stringify(msg)}, `;\n      } else {\n        message += `${msg}, `;\n      }\n    });\n    return message.length > 0 ? message.slice(0,message.length-2) : \"\";\n  }\n}\n","import { LoggerStaticInfo, LogOptions, LogLevel } from \"../fit-logger-core/logging.models\";\r\nimport { LoggingController } from \"./logwriters/logging.controller\";\r\nimport { ApplicationLogger } from \"../fit-logger-core/index\";\r\nimport { Logger } from \"./logwriters/app.logger\";\r\n\r\n// import { Logger } from './../logwriters/app.logger';\r\n// import { LogLevel, ApplicationLogger } from '../fit-logger-core/index';\r\n\r\n\r\n\r\n\r\nexport class FitWorkerLoggerService {\r\n  private static _instance = new FitWorkerLoggerService();\r\n\r\n  constructor() {\r\n    if (FitWorkerLoggerService._instance) {\r\n      throw new Error(\"Error: Instantiation failed: Use FitWorkerLoggerService.instance instead of new.\");\r\n    }\r\n    FitWorkerLoggerService._instance = this;\r\n  }\r\n  public init(loggerStaticInfo: LoggerStaticInfo, options?: LogOptions) {\r\n    LoggingController.instance.initialize(loggerStaticInfo,options);\r\n  }\r\n  getLogger(name: string, level?: LogLevel) : ApplicationLogger {\r\n    return new Logger(name, level);\r\n  }\r\n\r\n  static get instance(): FitWorkerLoggerService {\r\n    return FitWorkerLoggerService._instance;\r\n  }\r\n\r\n}\r\n","import { WorkerAgent } from './worker-agent';\nimport { FitWorkerLoggerService } from '../fit-logger/fit-worker-logger.service';\n\n\nFitWorkerLoggerService.instance.init({appName: 'MainApp'})\nconst logger = FitWorkerLoggerService.instance.getLogger('DedicatedWorkerGateway');\n\nlogger.info('Worker gateway file is opened');\n\nWorkerAgent.instance.setContext(self,true);\n\nself.addEventListener('message', (evt: MessageEvent) => {\n    WorkerAgent.instance.onMessage(evt.data);\n});\n\nself.addEventListener('messageerror', (evt: ErrorEvent) => {\n    console.error(evt);\n});\n"],"names":["tryCatcher","tryCatchTarget","apply","this","arguments","e","errorObject_1","errorObject","flattenUnsubscriptionErrors","errors","reduce","errs","err","concat","UnsubscriptionError_1","UnsubscriptionError","pipeFromArray","fns","length","input","prev","fn","noop_1","noop","LogLevel","WorkerMessageTypes","Object","freeze","CONNECT_WORKER","CONNECT_WORKER_SUCCESS","CONNECT_WORKER_FAILED","SET_WORKER_CONFIG","WORKER_READY","CONNECT_SOCKET","CONNECT_SOCKET_SUCCESS","CONNECT_SOCKET_FAILED","SUBSCRIBE_DATA","SUBSCRIBE_DATA_FAILED","payload","WorkerMessageBuilder","type","message","WorkerMessage","WorkerAgent","_instance","Error","context","sendConnected","dispatchMessage","build","name","postMessage","options","ServerAppender","loggingEvent","console","info","JSON","stringify","appenderOptions","ConsoleAppender","logLevel","OFF","level","getFormattedMessage","DEBUG","debug","ERROR","FATAL","error","INFO","appName","getFormattedTime","timestamp","date","Date","getMonth","getDate","getFullYear","getHours","getMinutes","getSeconds","getMilliseconds","WebWorkerAppender","isWorkerReady","worker","port","dispose","SharedWorker","path","addEventListener","onWorkerError","bind","onWorkerMessage","start","errorEvt","evt","data","removeEventListener","close","Map","AppenderRepository","appenderMap","set","format","isDefferred","has","get","__window","window","__self","self","WorkerGlobalScope","_root","global","x","Array","isArray","__extends","d","b","__","constructor","p","hasOwnProperty","prototype","create","_super","call","map","i","toString","join","stack","Subscription","unsubscribe","closed","_parent","_parents","_subscriptions","_unsubscribe","hasErrors","index","len","remove","isFunction_1","isFunction","tryCatch_1","tryCatch","isArray_1","sub","isObject_1","isObject","push","add","teardown","EMPTY","subscription","_addParent","tmp","subscriptions","subscriptionIndex","indexOf","splice","parent","empty","next","value","complete","Symbol","root_1","root","exports","for","rxSubscriber","Subscriber","destinationOrNext","syncErrorValue","syncErrorThrown","syncErrorThrowable","isStopped","destination","Observer_1","SafeSubscriber","rxSubscriber_1","subscriber","_next","_error","_complete","_unsubscribeAndRecycle","Subscription_1","_parentSubscriber","observerOrNext","_context","__tryOrSetError","__tryOrUnsub","_this","wrappedComplete","nextOrObserver","Subscriber_1","getSymbolObservable","$$observable","observable","_i","Observable","subscribe","_isScalar","_subscribe","lift","operator","source","sink","toSubscriber_1","toSubscriber","_trySubscribe","forEach","PromiseCtor","Rx","config","Promise","resolve","reject","observable_1","pipe","operations","pipe_1","toPromise","val","parseFloat","Action","scheduler","work","schedule","state","delay","AsyncAction","pending","id","recycleAsyncId","requestAsyncId","setInterval","flush","clearInterval","execute","_execute","errored","errorValue","undefined","actions","Action_1","Scheduler","SchedulerAction","now","AsyncScheduler","active","scheduled","action","shift","Scheduler_1","AsyncAction_1","IntervalObservable","period","async_1","async","isNumeric_1","isNumeric","dispatch","Observable_1","interval","interval_1","predicate","thisArg","FilterOperator","FilterSubscriber","count","result","filter_1","filter","LogWriter","appender","appenders","ImmediateLogWriter","DefferredLogger","logEvent","key","writeLog","logEvents","writeEvents","writeLogs","getImmediateLogWriter","LoggingController","loggerStaticInfo","resolveStaticInfo","_logOptions","getDefaultOptions","instance","getAppender","logInterval","defLogWriter","getDefferredWriter","update","addAppender","immedWriter","_staticInfo","user","region","env","addLogEntry","staticInfo","appLogLevel","ALL","loggerName","moduleLogLevel","Logger","params","buildLoggingEvent","messages","TRACE","WARN","initiallyExpanded","timer","startTime","delete","expr","LoggingEvent","buildMessage","enqueue","msg","slice","FitWorkerLoggerService","initialize","init","getLogger","setContext","onMessage"],"mappings":"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"}